## 重学前端

1. 为什么有的编程规范要求用 `void 0` 代替 `undefined`？

   > `JavaScript` 的代码 `undefined` 是一个变量，而并非是一个关键字，这是 `JavaScript` 语言公认的设计失误之一，所以，我们为了避免无意中被篡改，建议使用 `void 0` 来获取 `undefined` 值。

2. `Undefined` 和 `Null` 的区别

- `Undefined`: `Undefined` 类型表示未定义，它的类型只有一个值，就是 `undefined`; `JavaScript` 的代码 `undefined` 是一个变量，而并非是一个关键字，这是 `JavaScript` 语言公认的设计失误之一；
- `Null`: `Null` 类型也只有一个值，就是 `null`，它的语义表示控制，与 `undefined` 不同, `null` 是 `JavaScript` 中的关键字，所以在任何代码中，你都可以放心的用 `null` 关键字来获取 `null` 值；

> `Undefined` 跟 `Null` 有一定的表意差别，`Null` 表示的是：“定义了但是为空”。所以，在实际编程时，我们一般不会把变量赋值为 `undefined`，这样可以保证所有值为 `undefined` 的变量，都是从未赋值的自然状态。

3. `JavaScript` 中的 `String` 是否有最大长度?

- 答案当然是有的，`String` 有最大长度是 `2^53 - 1`;

> 这个所谓最大长度，并不完全是你理解中的字符数。因为 String 的意义并非“字符串”，而是字符串的 UTF16 编码，我们字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16 编码。所以，字符串的最大长度，实际上是受字符串的编码长度影响的。

> _现行的字符集国际标准，字符是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符，理论上，Unicode 的范围是无限的。UTF 是 Unicode 的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。 Unicode 的码点通常用 U+??? 来表示，其中 ??? 是十六进制的码点值。 0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）。_

> JavaScript 字符串把每个 UTF16 单元当作一个字符来处理，所以处理非 BMP（超出 U+0000 - U+FFFF 范围）的字符时，你应该格外小心。_JavaScript 这个设计继承自 Java，最新标准中是这样解释的，这样设计是为了“性能和尽可能实现起来简单”。因为现实中很少用到 BMP 之外的字符。_

4. Number 的长度？

- Number 类型有 `18437736874454810627`(即 `2^64-2^53+3`) 个值

5. 为什么 JavaScript 中 x/0 不会报错？

- JavaScript 为了表达几个额外的语言场景（比如不让除以 0 出错，而引入了无穷大的概念），规定了几个例外情况：
  1. `NaN`，占用了 `9007199254740990`，这原本是符合 `IEEE` 规则的数字；
  2. `Infinity`，无穷大；
  3. `-Infinity`，负无穷大。

> 另外，值得注意的是，JavaScript 中有 `+0` 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以 -0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。

6. 为什么 `0.1 + 0.2` 不等于 `0.3`？

```JavaScript
console.log( 0.1 + 0.2 === 0.3); // false
```

> 根据双精度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。同样根据浮点数的定义，非整数的 Number 类型无法用 ==（=== 也不行） 来比较：
> 这是浮点运算的特点，也是很多同学疑惑的来源，浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。

- 所以实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用 JavaScript 提供的最小精度值：

```JavaScript
// 检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。
console.log( Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON);
```

7. 为什么给对象添加的方法能用在基本类型上？

> JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：Number；String；Boolean；Symbol。
>
> 1. 我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。
> 2. Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。
> 3. Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。

```JavaScript
console.log("abc".charAt(0)); //a

Symbol.prototype.hello = () => console.log("hello");

var a = Symbol("a");
console.log(typeof a); //symbol，a并非对象
a.hello(); // hello，有效
```

- 所以这里总结答案就是 `.` 运算符提供了`装箱操作`，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。

8. 什么是装箱转换？

- 每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。

> 装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。

9. 为什么我们常用 `Object.prototype.toString` 来获取对象类型?

- 每一类装箱对象皆有私有的 Class 属性，这些属性可以用 `Object.prototype.toString` 获取;
- 在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 `Object.prototype.toString` 是可以准确识别对象对应的基本类型的方法，它比 `instanceof` 更加准确。

```JavaScript
var symbolObject = Object(Symbol("a"));
console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]
```

> 但需要注意的是，`call` 本身会产生装箱操作，所以需要配合 `typeof` 来区分基本类型还是对象类型。

10. 什么是拆箱转换？

- 在 `JavaScript` 标准中，规定了 `ToPrimitive` 函数，它是对象类型到基本类型的转换（即，拆箱转换）

> 对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。

- 拆箱转换会尝试调用 `valueOf` 和 `toString` 来获得拆箱后的基本类型。如果 `valueOf` 和 `toString` 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。

```JavaScript
var o = {
  valueOf: () => {console.log("valueOf"); return {}},
  toString: () => {console.log("toString"); return {}}
}

// Number 的转换  先 valueOf 再 toString
o * 2 // TypeError

// String 的转换则是 先 toString 再 valueOf
String(o) // TypeError

// 在 ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为。
o[Symbol.toPrimitive] = () => {console.log("toPrimitive"); return "hello"}
// toPrimitive
console.log(o + "")  // hello
```
